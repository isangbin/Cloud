# Cloudie

## 1. 개요

> 아이디어 배경

본인이 본 영화 중 재밌었던 영화들에 like를 눌러주면 해당 영화들의 장르를 분석해 해당 user가 가장 좋아할 만한 장르의 영화를 추천해줄 수 있는 웹사이트를 개발하고자 하였다.

### 1-1. 파일 구성

file tree 사진



### 1-2. DB 모델링

ERD 사진



## 2. 프로젝트 목표

### 2-1. 서비스 목표

1. api를 활용한 영화정보 db 구성 및 실시간 영화 데이터 산출
2. 해당 데이터들을 이용한 최신영화, 추천영화, 모든영화 목록을 display
3. community를 활용한 user들간의 소통
4. follower 및 following기능과 이를 기반으로 내 친구가 좋아하는 영화들을 알 수 있도록 하는 서비스 구현
5. 영화 취향이 비슷한 user를 매칭해주는 데이트 매칭 기능 구현



### 2-2. 팀원 정보 및 업무 분담

1. 사이좋게 같이했어요 를 멋지게 쓰기



### 2-3. 대표 기능

1. movies

   1. TMDB api를 통해 영화데이터를 제공받아 DB에 저장하여 활용한다.
   2. user는 로그인 시 다양한 영화를 추천받는다. 추천 받는 내용은 아래와 같다.
      1. TMDB로부터 실시간으로 받아오는 최신 인기영화 목록
      2. user가 'like'한 영화들의 장르를 기반으로 선정된 user 전용 추천 영화 목록
      3. db에 존재하는 모든 영화 목록
   3. 추천목록의 각 영화 포스터를 클릭하면 영화별 세부 정보 페이지로 이동할수 있다.

   

2. accounts

   1. user는 로그인을 해야만 사이트 이용이 가능하도록 되어있다.
   2. 회원 가입, 회원 탈퇴, 회원정보 수정, 비밀번호 변경, 로그인, 로그아웃 기능이 구현되어있다.
   3. 모든 user는 각자의 profile 페이지가 존재하며, 본인의 profile과 타인의 profile에 접속시 보여지는 화면이 다르다.
      1. 본인의 profile에 접속할 경우 팔로워, 팔로잉, 작성 게시글 수, 작성 댓글 수와 프로필 사진, like한 영화들의 포스터가 보여지고, 각 포스터를 클릭하면 해당 영화의 세부정보 페이지로 이동된다.
      2. 타인의 profile에 접속할 경우ㅇㅇㅇ
   4. 매칭시스템 할거면 써야됨 여기다가ㅇㅇㅇ

   

3. community

   1. 모든 user는 review 게시글을 작성할 수 있다.
   2. 게시글은 게시글 제목, review할 영화 제목, 본인이 주는 평점, review 내용으로 이루어져 있다.
   3. user는 본인이 작성한 review를 포함한 모든 게시글에 좋아요를 누를 수 있고, 다시 누르면 취소된다.
   4. 게시글들은 작성, 삭제, 수정, 조회가 모두 가능하다.
   5. community 메인 페이지에서는 최근에 작성된 게시글이 맨 위로 계속 쌓이는 방식으로 모든 게시글을 보여주며, 클릭할 경우 댓글을 달 수 있는 게시글 세부 페이지로 이동한다.
   6. 모든 user는 게시글의 세부 페이지에서 댓글을 달 수 있고, 게시글과 마찬가지로 좋아요와 좋아요 취소가 가능하다.

## 3. 실제 구현 정도

> 사용 아키텍처 : Django & Vanilla JavaScript

####  계정

- 유저 정보
  - User 모델은 AbstractUser를 상속받아 사용했다.
    - 기본 User에 유저끼리 팔로잉을 할 수 있도록 followings라는 ManyToManyField를 추가해 주었다.
    - following은 유저가 유저 자신을 참조하는 방식이므로 'self'인자를 포함했고  symmetrical=False로 설정하였다.
 - 유저 생성
    - UserCreationForm을 상속받아 CustomUserCreationForm을 활용했다.
    - widget을 통해 placeholder를 추가해 디자인적으로 깔끔하도록 하였다.
 - 유저 수정
    - UserChangeForm을 상속받아 CustomUserChangeForm을 활용했다.
    - email, 성, 이름을 수정할 수 있도록 하였다.
 - 유저 인증
    - AuthenticationForm을 상속받아 CustomAuthenticationForm을 활용하였다.
    - UserCreationForm과 마찬가지로 label과 widget을 설정해 주었다.
  - ㅇㅇ
    - ㅇㅇㅇ
- 프로필
  - user
    - user와 OneToOneField를 설정해 각각의 유저가 한개의 프로필을 갖도록 하였다.
    - 프로필의 image 필드에는 프로필 사진을 설정할 수 있도록 하였다.
       - 이미지는 300, 300 사이즈 이상일 시 300으로 맞춰 저장되도록 하였다.
       - 기본 이미지는 media/sample.png 이고 유저들이 변경한 프로필 사진들은 /media/static/에 저장된다.

- change_password
   -  회원 정보 변경 시 change_password로 연결할 수 있어 해당 페이지에서 비밀번호를 변경할 수 있다.
- login
   - 저장된 유저 정보를 입력하면 login상태를 유지한채로 movies/index 페이지로 이동된다.
   - 유저가 로그인을 한 경우 navbar의 계정 버튼 dropdown은 프로필, 유저 정보 수정, 회원탈퇴, 로그아웃 항목으로 표시된다.
   - 유저가 로그인을 하지 않은 경우 dropdown은 로그인, 회원가입 항목으로 표시된다.

- profile
   - 프로필 페이지에는 다음과 같은 항목들이 표시된다.
      - 프로필 이미지 : 이미지 아래의 버튼 클릭시 이미지를 변경할 수 있는 update 페이지로 이동
      - 팔로잉, 팔로워 : 해당 유저를 팔로잉하고 있는 사람의 수와 해당 유저가 팔로잉 하고 있는 사람의 수를 표시함
      - 작성한 게시글 수 : 해당 유저가 작성한 게시들을 확인할 수 있다.
      - 좋아요 누른 게시글 수 : 해당 유저가 좋아요한 게시글 수 를 확인할 수 있다.
- signup
   - 유저가 회원가입을 할 수 있는 페이지
   - 유저명과 나이, 성별, 이메일 주소, 전화번호, 자기소개의 항목을 가진다.
   - 이미 계정이 있는 경우 아래의 login버튼을 통해 login 페이지로 이동할 수 있다.
- update
   -  유저의 정보를 변경하는 페이지
   -  처음에는 기본 이미지로 표시되지만 프로필 이미지를 변경할 수 있다.
   -  이메일과 이름을 수정할 수 있으며 비밀번호를 변경할 수 있는 페이지로 이동할 수도 있다.



#### 영화

- 영화 정보
  - TMDB API를 사용하여 python 코딩을 통해 ㅇㅇㅇㅇ개의 영화 정보를 받아 json파일로 저장했다. 이 때 저장된 영화 정보의 장르 데이터가 pk로 되어있었기 때문에 추가로 같은 방법을 사용하여 영화장르 데이터도 json파일에 추가하여 저장했다.
  - TMDB API에서 제공하는 popular, now playing등의 실시간 영화 추천 정보를 받아오기 위해 axios를 활용하였다.
- 영화 모델은 아래와 같이 구성했다.
  - Genre 
    - json화한 장르데이터를 담기 위한 모델로, 구성은 아래와 같다.
      - genre_id : 영화데이터의 genre의 pk를 담기 위한 필드이다.
      - name : 각 pk의 이름을 담기 위한 필드이다.
  - Movie
    - json화한 영화데이터를 담기 위한 모델로, 구성은 아래와 같다.
      - genres : 영화 장르 필드이고, Genre 모델과 M:N 관계를 가진다.
      - like_users : 해당 영화를 like 한 user목록으로, User 모델과 M:N 관계를 가진다.
      - poster_path : 영화 포스터의 url을 담기 위한 필드이다.
      - overview : 영화의 요약 줄거리를 담기 위한 필드이다.
      - release_date : 영화 개봉일을 담기 위한 필드이다.
      - movie_id : 영화데이터에서 영화의 id값을 담기 위한 필드이다.
      - title : 영화 제목을 담기 위한 필드이다.
      - popularity : 영화 관객 수를 담기 위한 필드이다.
      - runtime : 영화의 총 상영시간을 담기 위한 필드이다.
      - vote_average : 영화의 평점을 담기 위한 필드이다.  
- select
  - 해당 페이지는 유저가 회원 가입 후 바로 연결되고, 이후엔 로그인 상태로 navbar의 select버튼을 통해 이동할 수 있다.
  - database에 담긴 영화 중 popularity가 높은 40개의 영화 중 유저가 맘에드는 영화들을 선택할 수 있다.
  - 영화선택과 취소를 자유롭게 할 수 있고, 선택된 영화는 흐리게 표시되어 시각적으로 구분할 수 있다.
  - 선택된 영화들의 정보는 개인 프로필 페이지에서 확인할 수 있으며 추천 영화를 선별하기 위한 장르 데이터 분석에도 반영된다.
  - 영화 선택을 중단하고 싶으면 스크롤을 따라다니는 end select 버튼을 클릭해 언제든 중단할 수 있다.


- index
  - movie app의 메인 페이지에서는 인기 영화, 현재 상영작, 상영 예정작, 높은 평점, user가 좋아요 한 영화, user가 좋아하는 장르의 영화, 랜덤 영화를 display한다. 각 구현 내용은 아래와 같다.
    - 인기 영화
      - api와 axios를 이용한 비동기 통신으로 tmdb로부터 실시간으로 trending 영화들의 목록을 받아온다.
    - 현재 상영작
      - api와 axios를 이용한 비동기 통신으로 tmdb로부터 실시간으로 now_playing 영화들의 목록을 받아온다.
    - 상영 예정작
      - api와 axios를 이용한 비동기 통신으로 tmdb로부터 실시간으로 upcoming 영화들의 목록을 받아온다.
    - 높은 평점
      - api와 axios를 이용한 비동기 통신으로 tmdb로부터 실시간으로 top rated 영화들의 목록을 받아온다.
    - user가 좋아요 한 영화
      - 회원가입 후 select에서 user가 직접 like 한 영화들의 목록이 display된다. 해당 페이지는 상단 navbar의 Select 항목을 통해 언제든지 다시 이동이 가능하고 또한 좋아요 취소 및 다른 영화에 대한 좋아요를 통해 목록을 상시 변경할 수 있다.
    - user가 좋아하는 장르의 영화
      - select 페이지에서 본인이 좋아요 누른 영화의 json 데이터에는 해당 영화의 장르가 pk값으로 저장되어있다.  각 pk값과 pk_cnt를 딕셔너리로 만든 뒤 user가 like한 모든 영화들의 데이터를 순회하면서 각 pk가 얼마나 많이 중복되었는지를 체크한 뒤 value(pk_cnt)가 가장 높은 key(pk)를 pk로 갖는 장르를 포함한 영화 중 12개를 뽑아 display한다.
    - 랜덤 영화
      - json화하여 load해둔 모든 영화데이터 중 랜덤으로 12개의 영화를 뽑아 display한다.
- detail
  - detail 페이지는 database가 아니라 실시간으로 가져온 영화에 대한 정보를 표시해야 할 수도 있기 때문에 유저가 특정 영화를 클릭 시 detail 페이지에서 다시 axios를 활용해 영화 정보를 불러왔다.
  - tmdb api에서 특정 영화의 detail정보를 가져오기 위해서는 해당 영화의 id가 필요하기 때문에 detail 페이지로 전달된 영화의 id 정보를 javascript로 넘겨주어 활용하였다.
  - 특정 영화에 대해 포스터 url이 존재하지 않는 경우 '포스터 준비중'이라는 자체 이미지를 표시하였다.



- community
  - model
     - Review 모델은 다음의 field를 가진다.
        - title : 게시글의 제목을 담기 위한 필드이다.
        - movie_title : 게시글을 작성하려는 관련 영화 제목을 담기 위한 필드이다.
        - rank : user가 주는 영화의 평점을 저장할 필드이다.
        - content : 게시글의 내용을 담기 위한 필드이다.
        - created_at : 게시글 생성 시점을 담기 위한 필드이다.
        - updated_at : 게시글 수정 시점을 담기 위한 필드이다.
        - user : 해당 게시글을 작성한 User이고, User모델과 N : 1관계를 가진다.
        - like_users : 해당 게시글에 좋아요를 누른 User목록이고, User모델과 M : N관계를 가진다.

     - Comment 모델은 다음의 field를 가진다.
        - review : 댓글을 단 Review이고, Review모델과 N : 1 관계를 가진다.
        - user : 댓글을 작성한 User이고,  User모델과 N : 1 관계를 가진다.
        - content : 댓글의 내용을 담기 위한 필드이다.
        - like_users : 댓글에 좋아요를 누른 User들의 목록이고, User모델과 M : N 관계를 가진다.
  - index
     - index페이지에서는 현재 작성되어 있는 게시글들을 확인할 수 있다.
     - 게시글들은 아래로 쌓이면서 가장 나중에 작성된 게시물이 최상단에 나타나도록 배치했다.
     - 각 게시글 마다 좌측 하단에 클릭이 가능한 좋아요 버튼이 있고, 다시 클릭하면 취소된다.
     - index에서는 게시글의 작성자, 작성시간, 관련 영화 및 게시글 제목을 확인할 수 있다.
       - 작성자의 이름을 클릭하면 작성자의 profile 페이지로 이동할 수 있다.
     - 각 게시글마다 우측 하단에 클릭이 가능한 Detail 버튼이 있고, 클릭 시 해당 게시글의 세부 페이지로 이동할 수 있다. 
  - create
     - 게시글을 새로 생성할 수 있는 페이지
     - 항목은 상기의 Review 모델의 항목과 동일하다(created_at, updated_at, user, like_users 제외)
     - 작성한 게시글 수는 개인 프로필에서 확인할 수 있다.
  - detail
     - index 페이지에서 한 게시글의 detail 버튼을 클릭 시 이동할 수 있다.
     - detail은 게시글 영역과 댓글 영역이 존재한다.
     - 게시글영역에는 작성자 이름, 관련 영화 제목, 게시글 제목, 작성 시간, 최종 수정 시간, 게시글 내용이 있다.
       - 작성자 이름을 클릭하면 작성자의 profile 페이지로 이동할 수 있다.
       - 게시글 작성자가 본인의 게시글의 detail 페이지로 들어가면 게시글 수정 버튼, 게시글 삭제 버튼이 나타난다.
         - 게시글 수정 버튼을 클릭하면 게시글의 각 항목을 수정할 수 있는 페이지로 이동할 수 있다.
         - 게시글 삭제 버튼을 클릭하면 게시글을 삭제할 수 있다.
     - 댓글 영역은 count()를 사용해 몇 개의 댓글이 달렸는지를 확인할 수 있는 문구와 그 아래로 모든 댓글이 나타나도록 구성했다.
       - 각 댓글에는 클릭이 가능한 좋아요 버튼이 있고, 다시 클릭하면 취소된다.
       - 본인이 작성한 댓글의 경우엔 댓글 삭제 버튼이 있고, 클릭하면 댓글을 삭제할 수 있다.
   - update
     - 본인 게시글의 detail페이지에서 게시글 수정 버튼을 클릭하여 이동할 수 있는 페이지이다.
     - 게시글을 작성할때와 같은 항목들을 display하며, 아무것도 입력하지 않은 상태일 땐 원래 내용이 적혀있다.
     - 하단의 수정 버튼을 클릭하면 수정사항이 적용되고, 취소 버튼을 클릭하면 수정 작업이 취소된다.
   - delete
     - 본인이 작성한 게시글의 detail페이지에서 게시글 삭제 버튼을 클릭하면 삭제 작업이 실행되도록 연결되어있는 버튼이다.


## 프로젝트 후기

### 임상빈

good

### 손승환

cool



어떤주제햇는지 서비스목표는이거다 이런걸구현햇고 계획한거 이정돈데 이만큼 채웟다

또는 ~~한기능들을 구현햇다

어떻게 협업햇고 누가이거를햇고 어떠한성과를낼수있었다

이걸통해서 무엇을 배웟는지

깃헙 잘쓸수잇게됏다 브랜치잘쓸수잇게됐다 숙제할땐복붙해서냈는데 직접해보니 난멀었다

난 준비가 된거같다 사회로나가야겟다 등등



코드를 먼저 보여주는건 비효율적

코드베이스보다는 어떤주제로 뭘했는지 시각화해서 보여주는게 좋음

캡처하는거 good -> 시연할때 안되는경우가 있을수있음. 이때 캡처본이라도 보여주면 덜억울함

